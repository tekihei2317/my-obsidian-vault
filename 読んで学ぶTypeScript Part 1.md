# 読んで学ぶTypeScript Part 1

### nullとundefinedの違い

nullとundefinedの違いはなにかというと、nullは「代入すべき値がない」undefinedは「代入していないので値がない」という意味です。

意味に応じて使い分けるべきという意見もありますが、**使い分けるメリットはあまりないため、こだわりがなければundefinedに統一することが本書ではおすすめされていました**。実際、TypeScriptの開発チームは「nullは使わずundefinedを使う」というシンプルなコーディングルールを採用しているようです。

### ラッパーオブジェクトへの変換

JavaScriptのプリミティブ型（数値、文字列）にはメソッドがありませんが、メソッドを呼び出すときにラッパーオブジェクトに変換されるためメソッドを呼び出すことができます。このラッパーオブジェクトへの変換をボックス化といいます。

### オブジェクトのプロパティ

JavaScriptのオブジェクトはプロパティの集合です。プロパティには、数値や文字列といったプリミティブ型だけではなく、関数を代入することもできます。これはいわゆるメソッドです。

双変と共変、気になる...。

### readonlyについて

readonlyはプロパティへの代入を制限するものです。一方でconstは、変数への代入を制限するものです。readonlyをすべてのプロパティに付与したい場合は、組み込みの`Readonly<T>`型が便利です。


### 余剰プロパティチェックについて

オブジェクト型にの変数対してオブジェクトリテラルを代入するときのみ、余剰プロパティのチェックが行われます。

```ts
const xy: { x: number; y: number } = { x: 1, y: 2 };
let onlyX: { x: number };
// onlyX = { x: 1, y: 2 }; // コンパイルエラーになる
onlyX = xy;
console.log(onlyX); // { x: 1, y: 2 }
```

noUncheckedIndexedAccessをオンにすると、厳密に定義していない（インデックス型で定義した）プロパティにアクセスしたときの型が、インデックス型で指定した型とundefined型のユニオンになります。

### その他、知らなかったこと

- object型はプリミティブ以外を表す型で、Object型と{}型はプロパティを持つ任意の値を表す型である
- ネストしたプロパティでも分割代入できる

### 構造的部分型について

TypeScriptでは、シグネチャが同じでえあれば別のオブジェクト型の変数にも代入できます。これを構造的部分型と呼びます。

### 配列の要素へのアクセスについて

noUncheckedIndexedAccessをオンにすると、型が`T[]`の配列の要素にアクセスすると`T | undefined`型になります。ちょっと面倒くさそうですが推奨されているようです。


### 判別可能なユニオン型

便利そう。オブジェクトのユニオン型を扱うとき、プリミティブ型（またはnull型、undefined型）の共通のプロパティを持たせると、条件分岐をしたときにユニオンのうちのどの型かを判別することができます。この共通のプロパティのことをディスクリミネータと呼びます。

